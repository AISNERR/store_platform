// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i route256/cart/internal/pkg/reviews/service.CartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mock

import (
	"context"
	"route256/cart/internal/pkg/reviews/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements mm_service.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateCart          func(ctx context.Context, cart model.Cart) (cp1 *model.Cart, err error)
	funcCreateCartOrigin    string
	inspectFuncCreateCart   func(ctx context.Context, cart model.Cart)
	afterCreateCartCounter  uint64
	beforeCreateCartCounter uint64
	CreateCartMock          mCartRepositoryMockCreateCart

	funcDelCart          func(ctx context.Context, user_id model.UserID, sku model.SKU) (err error)
	funcDelCartOrigin    string
	inspectFuncDelCart   func(ctx context.Context, user_id model.UserID, sku model.SKU)
	afterDelCartCounter  uint64
	beforeDelCartCounter uint64
	DelCartMock          mCartRepositoryMockDelCart

	funcDelWholeCart          func(ctx context.Context, user model.UserID) (err error)
	funcDelWholeCartOrigin    string
	inspectFuncDelWholeCart   func(ctx context.Context, user model.UserID)
	afterDelWholeCartCounter  uint64
	beforeDelWholeCartCounter uint64
	DelWholeCartMock          mCartRepositoryMockDelWholeCart

	funcGetCart          func(ctx context.Context, user_id model.UserID) (m1 map[model.SKU]model.ItemDetails, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(ctx context.Context, user_id model.UserID)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepositoryMockGetCart
}

// NewCartRepositoryMock returns a mock for mm_service.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCartMock = mCartRepositoryMockCreateCart{mock: m}
	m.CreateCartMock.callArgs = []*CartRepositoryMockCreateCartParams{}

	m.DelCartMock = mCartRepositoryMockDelCart{mock: m}
	m.DelCartMock.callArgs = []*CartRepositoryMockDelCartParams{}

	m.DelWholeCartMock = mCartRepositoryMockDelWholeCart{mock: m}
	m.DelWholeCartMock.callArgs = []*CartRepositoryMockDelWholeCartParams{}

	m.GetCartMock = mCartRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepositoryMockGetCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockCreateCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockCreateCartExpectation
	expectations       []*CartRepositoryMockCreateCartExpectation

	callArgs []*CartRepositoryMockCreateCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockCreateCartExpectation specifies expectation struct of the CartRepository.CreateCart
type CartRepositoryMockCreateCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockCreateCartParams
	paramPtrs          *CartRepositoryMockCreateCartParamPtrs
	expectationOrigins CartRepositoryMockCreateCartExpectationOrigins
	results            *CartRepositoryMockCreateCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockCreateCartParams contains parameters of the CartRepository.CreateCart
type CartRepositoryMockCreateCartParams struct {
	ctx  context.Context
	cart model.Cart
}

// CartRepositoryMockCreateCartParamPtrs contains pointers to parameters of the CartRepository.CreateCart
type CartRepositoryMockCreateCartParamPtrs struct {
	ctx  *context.Context
	cart *model.Cart
}

// CartRepositoryMockCreateCartResults contains results of the CartRepository.CreateCart
type CartRepositoryMockCreateCartResults struct {
	cp1 *model.Cart
	err error
}

// CartRepositoryMockCreateCartOrigins contains origins of expectations of the CartRepository.CreateCart
type CartRepositoryMockCreateCartExpectationOrigins struct {
	origin     string
	originCtx  string
	originCart string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCart *mCartRepositoryMockCreateCart) Optional() *mCartRepositoryMockCreateCart {
	mmCreateCart.optional = true
	return mmCreateCart
}

// Expect sets up expected params for CartRepository.CreateCart
func (mmCreateCart *mCartRepositoryMockCreateCart) Expect(ctx context.Context, cart model.Cart) *mCartRepositoryMockCreateCart {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CartRepositoryMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &CartRepositoryMockCreateCartExpectation{}
	}

	if mmCreateCart.defaultExpectation.paramPtrs != nil {
		mmCreateCart.mock.t.Fatalf("CartRepositoryMock.CreateCart mock is already set by ExpectParams functions")
	}

	mmCreateCart.defaultExpectation.params = &CartRepositoryMockCreateCartParams{ctx, cart}
	mmCreateCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCart.expectations {
		if minimock.Equal(e.params, mmCreateCart.defaultExpectation.params) {
			mmCreateCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCart.defaultExpectation.params)
		}
	}

	return mmCreateCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.CreateCart
func (mmCreateCart *mCartRepositoryMockCreateCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockCreateCart {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CartRepositoryMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &CartRepositoryMockCreateCartExpectation{}
	}

	if mmCreateCart.defaultExpectation.params != nil {
		mmCreateCart.mock.t.Fatalf("CartRepositoryMock.CreateCart mock is already set by Expect")
	}

	if mmCreateCart.defaultExpectation.paramPtrs == nil {
		mmCreateCart.defaultExpectation.paramPtrs = &CartRepositoryMockCreateCartParamPtrs{}
	}
	mmCreateCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCart
}

// ExpectCartParam2 sets up expected param cart for CartRepository.CreateCart
func (mmCreateCart *mCartRepositoryMockCreateCart) ExpectCartParam2(cart model.Cart) *mCartRepositoryMockCreateCart {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CartRepositoryMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &CartRepositoryMockCreateCartExpectation{}
	}

	if mmCreateCart.defaultExpectation.params != nil {
		mmCreateCart.mock.t.Fatalf("CartRepositoryMock.CreateCart mock is already set by Expect")
	}

	if mmCreateCart.defaultExpectation.paramPtrs == nil {
		mmCreateCart.defaultExpectation.paramPtrs = &CartRepositoryMockCreateCartParamPtrs{}
	}
	mmCreateCart.defaultExpectation.paramPtrs.cart = &cart
	mmCreateCart.defaultExpectation.expectationOrigins.originCart = minimock.CallerInfo(1)

	return mmCreateCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.CreateCart
func (mmCreateCart *mCartRepositoryMockCreateCart) Inspect(f func(ctx context.Context, cart model.Cart)) *mCartRepositoryMockCreateCart {
	if mmCreateCart.mock.inspectFuncCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.CreateCart")
	}

	mmCreateCart.mock.inspectFuncCreateCart = f

	return mmCreateCart
}

// Return sets up results that will be returned by CartRepository.CreateCart
func (mmCreateCart *mCartRepositoryMockCreateCart) Return(cp1 *model.Cart, err error) *CartRepositoryMock {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CartRepositoryMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &CartRepositoryMockCreateCartExpectation{mock: mmCreateCart.mock}
	}
	mmCreateCart.defaultExpectation.results = &CartRepositoryMockCreateCartResults{cp1, err}
	mmCreateCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCart.mock
}

// Set uses given function f to mock the CartRepository.CreateCart method
func (mmCreateCart *mCartRepositoryMockCreateCart) Set(f func(ctx context.Context, cart model.Cart) (cp1 *model.Cart, err error)) *CartRepositoryMock {
	if mmCreateCart.defaultExpectation != nil {
		mmCreateCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.CreateCart method")
	}

	if len(mmCreateCart.expectations) > 0 {
		mmCreateCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.CreateCart method")
	}

	mmCreateCart.mock.funcCreateCart = f
	mmCreateCart.mock.funcCreateCartOrigin = minimock.CallerInfo(1)
	return mmCreateCart.mock
}

// When sets expectation for the CartRepository.CreateCart which will trigger the result defined by the following
// Then helper
func (mmCreateCart *mCartRepositoryMockCreateCart) When(ctx context.Context, cart model.Cart) *CartRepositoryMockCreateCartExpectation {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CartRepositoryMock.CreateCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockCreateCartExpectation{
		mock:               mmCreateCart.mock,
		params:             &CartRepositoryMockCreateCartParams{ctx, cart},
		expectationOrigins: CartRepositoryMockCreateCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCart.expectations = append(mmCreateCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.CreateCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockCreateCartExpectation) Then(cp1 *model.Cart, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockCreateCartResults{cp1, err}
	return e.mock
}

// Times sets number of times CartRepository.CreateCart should be invoked
func (mmCreateCart *mCartRepositoryMockCreateCart) Times(n uint64) *mCartRepositoryMockCreateCart {
	if n == 0 {
		mmCreateCart.mock.t.Fatalf("Times of CartRepositoryMock.CreateCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCart.expectedInvocations, n)
	mmCreateCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCart
}

func (mmCreateCart *mCartRepositoryMockCreateCart) invocationsDone() bool {
	if len(mmCreateCart.expectations) == 0 && mmCreateCart.defaultExpectation == nil && mmCreateCart.mock.funcCreateCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCart.mock.afterCreateCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCart implements mm_service.CartRepository
func (mmCreateCart *CartRepositoryMock) CreateCart(ctx context.Context, cart model.Cart) (cp1 *model.Cart, err error) {
	mm_atomic.AddUint64(&mmCreateCart.beforeCreateCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCart.afterCreateCartCounter, 1)

	mmCreateCart.t.Helper()

	if mmCreateCart.inspectFuncCreateCart != nil {
		mmCreateCart.inspectFuncCreateCart(ctx, cart)
	}

	mm_params := CartRepositoryMockCreateCartParams{ctx, cart}

	// Record call args
	mmCreateCart.CreateCartMock.mutex.Lock()
	mmCreateCart.CreateCartMock.callArgs = append(mmCreateCart.CreateCartMock.callArgs, &mm_params)
	mmCreateCart.CreateCartMock.mutex.Unlock()

	for _, e := range mmCreateCart.CreateCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateCart.CreateCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCart.CreateCartMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCart.CreateCartMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCart.CreateCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockCreateCartParams{ctx, cart}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCart.t.Errorf("CartRepositoryMock.CreateCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCart.CreateCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cart != nil && !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) {
				mmCreateCart.t.Errorf("CartRepositoryMock.CreateCart got unexpected parameter cart, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCart.CreateCartMock.defaultExpectation.expectationOrigins.originCart, *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCart.t.Errorf("CartRepositoryMock.CreateCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCart.CreateCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCart.CreateCartMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCart.t.Fatal("No results are set for the CartRepositoryMock.CreateCart")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateCart.funcCreateCart != nil {
		return mmCreateCart.funcCreateCart(ctx, cart)
	}
	mmCreateCart.t.Fatalf("Unexpected call to CartRepositoryMock.CreateCart. %v %v", ctx, cart)
	return
}

// CreateCartAfterCounter returns a count of finished CartRepositoryMock.CreateCart invocations
func (mmCreateCart *CartRepositoryMock) CreateCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCart.afterCreateCartCounter)
}

// CreateCartBeforeCounter returns a count of CartRepositoryMock.CreateCart invocations
func (mmCreateCart *CartRepositoryMock) CreateCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCart.beforeCreateCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.CreateCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCart *mCartRepositoryMockCreateCart) Calls() []*CartRepositoryMockCreateCartParams {
	mmCreateCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockCreateCartParams, len(mmCreateCart.callArgs))
	copy(argCopy, mmCreateCart.callArgs)

	mmCreateCart.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCartDone returns true if the count of the CreateCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockCreateCartDone() bool {
	if m.CreateCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCartMock.invocationsDone()
}

// MinimockCreateCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockCreateCartInspect() {
	for _, e := range m.CreateCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.CreateCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCartCounter := mm_atomic.LoadUint64(&m.afterCreateCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartMock.defaultExpectation != nil && afterCreateCartCounter < 1 {
		if m.CreateCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.CreateCart at\n%s", m.CreateCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.CreateCart at\n%s with params: %#v", m.CreateCartMock.defaultExpectation.expectationOrigins.origin, *m.CreateCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCart != nil && afterCreateCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.CreateCart at\n%s", m.funcCreateCartOrigin)
	}

	if !m.CreateCartMock.invocationsDone() && afterCreateCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.CreateCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCartMock.expectedInvocations), m.CreateCartMock.expectedInvocationsOrigin, afterCreateCartCounter)
	}
}

type mCartRepositoryMockDelCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDelCartExpectation
	expectations       []*CartRepositoryMockDelCartExpectation

	callArgs []*CartRepositoryMockDelCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDelCartExpectation specifies expectation struct of the CartRepository.DelCart
type CartRepositoryMockDelCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDelCartParams
	paramPtrs          *CartRepositoryMockDelCartParamPtrs
	expectationOrigins CartRepositoryMockDelCartExpectationOrigins
	results            *CartRepositoryMockDelCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDelCartParams contains parameters of the CartRepository.DelCart
type CartRepositoryMockDelCartParams struct {
	ctx     context.Context
	user_id model.UserID
	sku     model.SKU
}

// CartRepositoryMockDelCartParamPtrs contains pointers to parameters of the CartRepository.DelCart
type CartRepositoryMockDelCartParamPtrs struct {
	ctx     *context.Context
	user_id *model.UserID
	sku     *model.SKU
}

// CartRepositoryMockDelCartResults contains results of the CartRepository.DelCart
type CartRepositoryMockDelCartResults struct {
	err error
}

// CartRepositoryMockDelCartOrigins contains origins of expectations of the CartRepository.DelCart
type CartRepositoryMockDelCartExpectationOrigins struct {
	origin        string
	originCtx     string
	originUser_id string
	originSku     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelCart *mCartRepositoryMockDelCart) Optional() *mCartRepositoryMockDelCart {
	mmDelCart.optional = true
	return mmDelCart
}

// Expect sets up expected params for CartRepository.DelCart
func (mmDelCart *mCartRepositoryMockDelCart) Expect(ctx context.Context, user_id model.UserID, sku model.SKU) *mCartRepositoryMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &CartRepositoryMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.paramPtrs != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by ExpectParams functions")
	}

	mmDelCart.defaultExpectation.params = &CartRepositoryMockDelCartParams{ctx, user_id, sku}
	mmDelCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelCart.expectations {
		if minimock.Equal(e.params, mmDelCart.defaultExpectation.params) {
			mmDelCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelCart.defaultExpectation.params)
		}
	}

	return mmDelCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DelCart
func (mmDelCart *mCartRepositoryMockDelCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &CartRepositoryMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.params != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Expect")
	}

	if mmDelCart.defaultExpectation.paramPtrs == nil {
		mmDelCart.defaultExpectation.paramPtrs = &CartRepositoryMockDelCartParamPtrs{}
	}
	mmDelCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelCart
}

// ExpectUser_idParam2 sets up expected param user_id for CartRepository.DelCart
func (mmDelCart *mCartRepositoryMockDelCart) ExpectUser_idParam2(user_id model.UserID) *mCartRepositoryMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &CartRepositoryMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.params != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Expect")
	}

	if mmDelCart.defaultExpectation.paramPtrs == nil {
		mmDelCart.defaultExpectation.paramPtrs = &CartRepositoryMockDelCartParamPtrs{}
	}
	mmDelCart.defaultExpectation.paramPtrs.user_id = &user_id
	mmDelCart.defaultExpectation.expectationOrigins.originUser_id = minimock.CallerInfo(1)

	return mmDelCart
}

// ExpectSkuParam3 sets up expected param sku for CartRepository.DelCart
func (mmDelCart *mCartRepositoryMockDelCart) ExpectSkuParam3(sku model.SKU) *mCartRepositoryMockDelCart {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &CartRepositoryMockDelCartExpectation{}
	}

	if mmDelCart.defaultExpectation.params != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Expect")
	}

	if mmDelCart.defaultExpectation.paramPtrs == nil {
		mmDelCart.defaultExpectation.paramPtrs = &CartRepositoryMockDelCartParamPtrs{}
	}
	mmDelCart.defaultExpectation.paramPtrs.sku = &sku
	mmDelCart.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmDelCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DelCart
func (mmDelCart *mCartRepositoryMockDelCart) Inspect(f func(ctx context.Context, user_id model.UserID, sku model.SKU)) *mCartRepositoryMockDelCart {
	if mmDelCart.mock.inspectFuncDelCart != nil {
		mmDelCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DelCart")
	}

	mmDelCart.mock.inspectFuncDelCart = f

	return mmDelCart
}

// Return sets up results that will be returned by CartRepository.DelCart
func (mmDelCart *mCartRepositoryMockDelCart) Return(err error) *CartRepositoryMock {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Set")
	}

	if mmDelCart.defaultExpectation == nil {
		mmDelCart.defaultExpectation = &CartRepositoryMockDelCartExpectation{mock: mmDelCart.mock}
	}
	mmDelCart.defaultExpectation.results = &CartRepositoryMockDelCartResults{err}
	mmDelCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelCart.mock
}

// Set uses given function f to mock the CartRepository.DelCart method
func (mmDelCart *mCartRepositoryMockDelCart) Set(f func(ctx context.Context, user_id model.UserID, sku model.SKU) (err error)) *CartRepositoryMock {
	if mmDelCart.defaultExpectation != nil {
		mmDelCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DelCart method")
	}

	if len(mmDelCart.expectations) > 0 {
		mmDelCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DelCart method")
	}

	mmDelCart.mock.funcDelCart = f
	mmDelCart.mock.funcDelCartOrigin = minimock.CallerInfo(1)
	return mmDelCart.mock
}

// When sets expectation for the CartRepository.DelCart which will trigger the result defined by the following
// Then helper
func (mmDelCart *mCartRepositoryMockDelCart) When(ctx context.Context, user_id model.UserID, sku model.SKU) *CartRepositoryMockDelCartExpectation {
	if mmDelCart.mock.funcDelCart != nil {
		mmDelCart.mock.t.Fatalf("CartRepositoryMock.DelCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDelCartExpectation{
		mock:               mmDelCart.mock,
		params:             &CartRepositoryMockDelCartParams{ctx, user_id, sku},
		expectationOrigins: CartRepositoryMockDelCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelCart.expectations = append(mmDelCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DelCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDelCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDelCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DelCart should be invoked
func (mmDelCart *mCartRepositoryMockDelCart) Times(n uint64) *mCartRepositoryMockDelCart {
	if n == 0 {
		mmDelCart.mock.t.Fatalf("Times of CartRepositoryMock.DelCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelCart.expectedInvocations, n)
	mmDelCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelCart
}

func (mmDelCart *mCartRepositoryMockDelCart) invocationsDone() bool {
	if len(mmDelCart.expectations) == 0 && mmDelCart.defaultExpectation == nil && mmDelCart.mock.funcDelCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelCart.mock.afterDelCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DelCart implements mm_service.CartRepository
func (mmDelCart *CartRepositoryMock) DelCart(ctx context.Context, user_id model.UserID, sku model.SKU) (err error) {
	mm_atomic.AddUint64(&mmDelCart.beforeDelCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDelCart.afterDelCartCounter, 1)

	mmDelCart.t.Helper()

	if mmDelCart.inspectFuncDelCart != nil {
		mmDelCart.inspectFuncDelCart(ctx, user_id, sku)
	}

	mm_params := CartRepositoryMockDelCartParams{ctx, user_id, sku}

	// Record call args
	mmDelCart.DelCartMock.mutex.Lock()
	mmDelCart.DelCartMock.callArgs = append(mmDelCart.DelCartMock.callArgs, &mm_params)
	mmDelCart.DelCartMock.mutex.Unlock()

	for _, e := range mmDelCart.DelCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelCart.DelCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelCart.DelCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDelCart.DelCartMock.defaultExpectation.params
		mm_want_ptrs := mmDelCart.DelCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDelCartParams{ctx, user_id, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelCart.t.Errorf("CartRepositoryMock.DelCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelCart.DelCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user_id != nil && !minimock.Equal(*mm_want_ptrs.user_id, mm_got.user_id) {
				mmDelCart.t.Errorf("CartRepositoryMock.DelCart got unexpected parameter user_id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelCart.DelCartMock.defaultExpectation.expectationOrigins.originUser_id, *mm_want_ptrs.user_id, mm_got.user_id, minimock.Diff(*mm_want_ptrs.user_id, mm_got.user_id))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmDelCart.t.Errorf("CartRepositoryMock.DelCart got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelCart.DelCartMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelCart.t.Errorf("CartRepositoryMock.DelCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelCart.DelCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelCart.DelCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDelCart.t.Fatal("No results are set for the CartRepositoryMock.DelCart")
		}
		return (*mm_results).err
	}
	if mmDelCart.funcDelCart != nil {
		return mmDelCart.funcDelCart(ctx, user_id, sku)
	}
	mmDelCart.t.Fatalf("Unexpected call to CartRepositoryMock.DelCart. %v %v %v", ctx, user_id, sku)
	return
}

// DelCartAfterCounter returns a count of finished CartRepositoryMock.DelCart invocations
func (mmDelCart *CartRepositoryMock) DelCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelCart.afterDelCartCounter)
}

// DelCartBeforeCounter returns a count of CartRepositoryMock.DelCart invocations
func (mmDelCart *CartRepositoryMock) DelCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelCart.beforeDelCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DelCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelCart *mCartRepositoryMockDelCart) Calls() []*CartRepositoryMockDelCartParams {
	mmDelCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDelCartParams, len(mmDelCart.callArgs))
	copy(argCopy, mmDelCart.callArgs)

	mmDelCart.mutex.RUnlock()

	return argCopy
}

// MinimockDelCartDone returns true if the count of the DelCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDelCartDone() bool {
	if m.DelCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DelCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DelCartMock.invocationsDone()
}

// MinimockDelCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDelCartInspect() {
	for _, e := range m.DelCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DelCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDelCartCounter := mm_atomic.LoadUint64(&m.afterDelCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DelCartMock.defaultExpectation != nil && afterDelCartCounter < 1 {
		if m.DelCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DelCart at\n%s", m.DelCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DelCart at\n%s with params: %#v", m.DelCartMock.defaultExpectation.expectationOrigins.origin, *m.DelCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelCart != nil && afterDelCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DelCart at\n%s", m.funcDelCartOrigin)
	}

	if !m.DelCartMock.invocationsDone() && afterDelCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DelCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DelCartMock.expectedInvocations), m.DelCartMock.expectedInvocationsOrigin, afterDelCartCounter)
	}
}

type mCartRepositoryMockDelWholeCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDelWholeCartExpectation
	expectations       []*CartRepositoryMockDelWholeCartExpectation

	callArgs []*CartRepositoryMockDelWholeCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDelWholeCartExpectation specifies expectation struct of the CartRepository.DelWholeCart
type CartRepositoryMockDelWholeCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDelWholeCartParams
	paramPtrs          *CartRepositoryMockDelWholeCartParamPtrs
	expectationOrigins CartRepositoryMockDelWholeCartExpectationOrigins
	results            *CartRepositoryMockDelWholeCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDelWholeCartParams contains parameters of the CartRepository.DelWholeCart
type CartRepositoryMockDelWholeCartParams struct {
	ctx  context.Context
	user model.UserID
}

// CartRepositoryMockDelWholeCartParamPtrs contains pointers to parameters of the CartRepository.DelWholeCart
type CartRepositoryMockDelWholeCartParamPtrs struct {
	ctx  *context.Context
	user *model.UserID
}

// CartRepositoryMockDelWholeCartResults contains results of the CartRepository.DelWholeCart
type CartRepositoryMockDelWholeCartResults struct {
	err error
}

// CartRepositoryMockDelWholeCartOrigins contains origins of expectations of the CartRepository.DelWholeCart
type CartRepositoryMockDelWholeCartExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) Optional() *mCartRepositoryMockDelWholeCart {
	mmDelWholeCart.optional = true
	return mmDelWholeCart
}

// Expect sets up expected params for CartRepository.DelWholeCart
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) Expect(ctx context.Context, user model.UserID) *mCartRepositoryMockDelWholeCart {
	if mmDelWholeCart.mock.funcDelWholeCart != nil {
		mmDelWholeCart.mock.t.Fatalf("CartRepositoryMock.DelWholeCart mock is already set by Set")
	}

	if mmDelWholeCart.defaultExpectation == nil {
		mmDelWholeCart.defaultExpectation = &CartRepositoryMockDelWholeCartExpectation{}
	}

	if mmDelWholeCart.defaultExpectation.paramPtrs != nil {
		mmDelWholeCart.mock.t.Fatalf("CartRepositoryMock.DelWholeCart mock is already set by ExpectParams functions")
	}

	mmDelWholeCart.defaultExpectation.params = &CartRepositoryMockDelWholeCartParams{ctx, user}
	mmDelWholeCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelWholeCart.expectations {
		if minimock.Equal(e.params, mmDelWholeCart.defaultExpectation.params) {
			mmDelWholeCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelWholeCart.defaultExpectation.params)
		}
	}

	return mmDelWholeCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DelWholeCart
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDelWholeCart {
	if mmDelWholeCart.mock.funcDelWholeCart != nil {
		mmDelWholeCart.mock.t.Fatalf("CartRepositoryMock.DelWholeCart mock is already set by Set")
	}

	if mmDelWholeCart.defaultExpectation == nil {
		mmDelWholeCart.defaultExpectation = &CartRepositoryMockDelWholeCartExpectation{}
	}

	if mmDelWholeCart.defaultExpectation.params != nil {
		mmDelWholeCart.mock.t.Fatalf("CartRepositoryMock.DelWholeCart mock is already set by Expect")
	}

	if mmDelWholeCart.defaultExpectation.paramPtrs == nil {
		mmDelWholeCart.defaultExpectation.paramPtrs = &CartRepositoryMockDelWholeCartParamPtrs{}
	}
	mmDelWholeCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelWholeCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelWholeCart
}

// ExpectUserParam2 sets up expected param user for CartRepository.DelWholeCart
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) ExpectUserParam2(user model.UserID) *mCartRepositoryMockDelWholeCart {
	if mmDelWholeCart.mock.funcDelWholeCart != nil {
		mmDelWholeCart.mock.t.Fatalf("CartRepositoryMock.DelWholeCart mock is already set by Set")
	}

	if mmDelWholeCart.defaultExpectation == nil {
		mmDelWholeCart.defaultExpectation = &CartRepositoryMockDelWholeCartExpectation{}
	}

	if mmDelWholeCart.defaultExpectation.params != nil {
		mmDelWholeCart.mock.t.Fatalf("CartRepositoryMock.DelWholeCart mock is already set by Expect")
	}

	if mmDelWholeCart.defaultExpectation.paramPtrs == nil {
		mmDelWholeCart.defaultExpectation.paramPtrs = &CartRepositoryMockDelWholeCartParamPtrs{}
	}
	mmDelWholeCart.defaultExpectation.paramPtrs.user = &user
	mmDelWholeCart.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmDelWholeCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DelWholeCart
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) Inspect(f func(ctx context.Context, user model.UserID)) *mCartRepositoryMockDelWholeCart {
	if mmDelWholeCart.mock.inspectFuncDelWholeCart != nil {
		mmDelWholeCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DelWholeCart")
	}

	mmDelWholeCart.mock.inspectFuncDelWholeCart = f

	return mmDelWholeCart
}

// Return sets up results that will be returned by CartRepository.DelWholeCart
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) Return(err error) *CartRepositoryMock {
	if mmDelWholeCart.mock.funcDelWholeCart != nil {
		mmDelWholeCart.mock.t.Fatalf("CartRepositoryMock.DelWholeCart mock is already set by Set")
	}

	if mmDelWholeCart.defaultExpectation == nil {
		mmDelWholeCart.defaultExpectation = &CartRepositoryMockDelWholeCartExpectation{mock: mmDelWholeCart.mock}
	}
	mmDelWholeCart.defaultExpectation.results = &CartRepositoryMockDelWholeCartResults{err}
	mmDelWholeCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelWholeCart.mock
}

// Set uses given function f to mock the CartRepository.DelWholeCart method
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) Set(f func(ctx context.Context, user model.UserID) (err error)) *CartRepositoryMock {
	if mmDelWholeCart.defaultExpectation != nil {
		mmDelWholeCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DelWholeCart method")
	}

	if len(mmDelWholeCart.expectations) > 0 {
		mmDelWholeCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DelWholeCart method")
	}

	mmDelWholeCart.mock.funcDelWholeCart = f
	mmDelWholeCart.mock.funcDelWholeCartOrigin = minimock.CallerInfo(1)
	return mmDelWholeCart.mock
}

// When sets expectation for the CartRepository.DelWholeCart which will trigger the result defined by the following
// Then helper
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) When(ctx context.Context, user model.UserID) *CartRepositoryMockDelWholeCartExpectation {
	if mmDelWholeCart.mock.funcDelWholeCart != nil {
		mmDelWholeCart.mock.t.Fatalf("CartRepositoryMock.DelWholeCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDelWholeCartExpectation{
		mock:               mmDelWholeCart.mock,
		params:             &CartRepositoryMockDelWholeCartParams{ctx, user},
		expectationOrigins: CartRepositoryMockDelWholeCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelWholeCart.expectations = append(mmDelWholeCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DelWholeCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDelWholeCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDelWholeCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DelWholeCart should be invoked
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) Times(n uint64) *mCartRepositoryMockDelWholeCart {
	if n == 0 {
		mmDelWholeCart.mock.t.Fatalf("Times of CartRepositoryMock.DelWholeCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelWholeCart.expectedInvocations, n)
	mmDelWholeCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelWholeCart
}

func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) invocationsDone() bool {
	if len(mmDelWholeCart.expectations) == 0 && mmDelWholeCart.defaultExpectation == nil && mmDelWholeCart.mock.funcDelWholeCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelWholeCart.mock.afterDelWholeCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelWholeCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DelWholeCart implements mm_service.CartRepository
func (mmDelWholeCart *CartRepositoryMock) DelWholeCart(ctx context.Context, user model.UserID) (err error) {
	mm_atomic.AddUint64(&mmDelWholeCart.beforeDelWholeCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDelWholeCart.afterDelWholeCartCounter, 1)

	mmDelWholeCart.t.Helper()

	if mmDelWholeCart.inspectFuncDelWholeCart != nil {
		mmDelWholeCart.inspectFuncDelWholeCart(ctx, user)
	}

	mm_params := CartRepositoryMockDelWholeCartParams{ctx, user}

	// Record call args
	mmDelWholeCart.DelWholeCartMock.mutex.Lock()
	mmDelWholeCart.DelWholeCartMock.callArgs = append(mmDelWholeCart.DelWholeCartMock.callArgs, &mm_params)
	mmDelWholeCart.DelWholeCartMock.mutex.Unlock()

	for _, e := range mmDelWholeCart.DelWholeCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelWholeCart.DelWholeCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelWholeCart.DelWholeCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDelWholeCart.DelWholeCartMock.defaultExpectation.params
		mm_want_ptrs := mmDelWholeCart.DelWholeCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDelWholeCartParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelWholeCart.t.Errorf("CartRepositoryMock.DelWholeCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelWholeCart.DelWholeCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmDelWholeCart.t.Errorf("CartRepositoryMock.DelWholeCart got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelWholeCart.DelWholeCartMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelWholeCart.t.Errorf("CartRepositoryMock.DelWholeCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelWholeCart.DelWholeCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelWholeCart.DelWholeCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDelWholeCart.t.Fatal("No results are set for the CartRepositoryMock.DelWholeCart")
		}
		return (*mm_results).err
	}
	if mmDelWholeCart.funcDelWholeCart != nil {
		return mmDelWholeCart.funcDelWholeCart(ctx, user)
	}
	mmDelWholeCart.t.Fatalf("Unexpected call to CartRepositoryMock.DelWholeCart. %v %v", ctx, user)
	return
}

// DelWholeCartAfterCounter returns a count of finished CartRepositoryMock.DelWholeCart invocations
func (mmDelWholeCart *CartRepositoryMock) DelWholeCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelWholeCart.afterDelWholeCartCounter)
}

// DelWholeCartBeforeCounter returns a count of CartRepositoryMock.DelWholeCart invocations
func (mmDelWholeCart *CartRepositoryMock) DelWholeCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelWholeCart.beforeDelWholeCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DelWholeCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelWholeCart *mCartRepositoryMockDelWholeCart) Calls() []*CartRepositoryMockDelWholeCartParams {
	mmDelWholeCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDelWholeCartParams, len(mmDelWholeCart.callArgs))
	copy(argCopy, mmDelWholeCart.callArgs)

	mmDelWholeCart.mutex.RUnlock()

	return argCopy
}

// MinimockDelWholeCartDone returns true if the count of the DelWholeCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDelWholeCartDone() bool {
	if m.DelWholeCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DelWholeCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DelWholeCartMock.invocationsDone()
}

// MinimockDelWholeCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDelWholeCartInspect() {
	for _, e := range m.DelWholeCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DelWholeCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDelWholeCartCounter := mm_atomic.LoadUint64(&m.afterDelWholeCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DelWholeCartMock.defaultExpectation != nil && afterDelWholeCartCounter < 1 {
		if m.DelWholeCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DelWholeCart at\n%s", m.DelWholeCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DelWholeCart at\n%s with params: %#v", m.DelWholeCartMock.defaultExpectation.expectationOrigins.origin, *m.DelWholeCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelWholeCart != nil && afterDelWholeCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DelWholeCart at\n%s", m.funcDelWholeCartOrigin)
	}

	if !m.DelWholeCartMock.invocationsDone() && afterDelWholeCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DelWholeCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DelWholeCartMock.expectedInvocations), m.DelWholeCartMock.expectedInvocationsOrigin, afterDelWholeCartCounter)
	}
}

type mCartRepositoryMockGetCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartExpectation
	expectations       []*CartRepositoryMockGetCartExpectation

	callArgs []*CartRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetCartExpectation specifies expectation struct of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetCartParams
	paramPtrs          *CartRepositoryMockGetCartParamPtrs
	expectationOrigins CartRepositoryMockGetCartExpectationOrigins
	results            *CartRepositoryMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetCartParams contains parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParams struct {
	ctx     context.Context
	user_id model.UserID
}

// CartRepositoryMockGetCartParamPtrs contains pointers to parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParamPtrs struct {
	ctx     *context.Context
	user_id *model.UserID
}

// CartRepositoryMockGetCartResults contains results of the CartRepository.GetCart
type CartRepositoryMockGetCartResults struct {
	m1  map[model.SKU]model.ItemDetails
	err error
}

// CartRepositoryMockGetCartOrigins contains origins of expectations of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectationOrigins struct {
	origin        string
	originCtx     string
	originUser_id string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartRepositoryMockGetCart) Optional() *mCartRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Expect(ctx context.Context, user_id model.UserID) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartRepositoryMockGetCartParams{ctx, user_id}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCart
}

// ExpectUser_idParam2 sets up expected param user_id for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectUser_idParam2(user_id model.UserID) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.user_id = &user_id
	mmGetCart.defaultExpectation.expectationOrigins.originUser_id = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Inspect(f func(ctx context.Context, user_id model.UserID)) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Return(m1 map[model.SKU]model.ItemDetails, err error) *CartRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepositoryMockGetCartResults{m1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CartRepository.GetCart method
func (mmGetCart *mCartRepositoryMockGetCart) Set(f func(ctx context.Context, user_id model.UserID) (m1 map[model.SKU]model.ItemDetails, err error)) *CartRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CartRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepositoryMockGetCart) When(ctx context.Context, user_id model.UserID) *CartRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CartRepositoryMockGetCartParams{ctx, user_id},
		expectationOrigins: CartRepositoryMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartExpectation) Then(m1 map[model.SKU]model.ItemDetails, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartResults{m1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCart should be invoked
func (mmGetCart *mCartRepositoryMockGetCart) Times(n uint64) *mCartRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCartRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_service.CartRepository
func (mmGetCart *CartRepositoryMock) GetCart(ctx context.Context, user_id model.UserID) (m1 map[model.SKU]model.ItemDetails, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, user_id)
	}

	mm_params := CartRepositoryMockGetCartParams{ctx, user_id}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartParams{ctx, user_id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user_id != nil && !minimock.Equal(*mm_want_ptrs.user_id, mm_got.user_id) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter user_id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originUser_id, *mm_want_ptrs.user_id, mm_got.user_id, minimock.Diff(*mm_want_ptrs.user_id, mm_got.user_id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepositoryMock.GetCart")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, user_id)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepositoryMock.GetCart. %v %v", ctx, user_id)
	return
}

// GetCartAfterCounter returns a count of finished CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepositoryMockGetCart) Calls() []*CartRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateCartInspect()

			m.MinimockDelCartInspect()

			m.MinimockDelWholeCartInspect()

			m.MinimockGetCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCartDone() &&
		m.MinimockDelCartDone() &&
		m.MinimockDelWholeCartDone() &&
		m.MinimockGetCartDone()
}
